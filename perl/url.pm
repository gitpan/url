# This file was automatically generated by SWIG
package url;
require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);

@EXPORT = qw( 

$URL_INFO_CANNONICAL
$URL_INFO_URL
$URL_INFO_FURL
$URL_INFO_RELATIVE
$URL_INFO_RELATIVE_PATH
$URL_INFO_EMPTY
$URL_INFO_HTTP
$URL_INFO_FTP
$URL_INFO_NEWS
$URL_INFO_FILE
$URL_INFO_ROBOTS
$URL_INFO_SCHEME_MASK
$URL_NOT_CANNONICAL
$URL_CANNONICAL
$URL_FURL_REAL_PATH
$URL_FURL_NOP
$URL_STRING_FURL_STYLE
$URL_STRING_URL_STYLE
$URL_STRING_ROBOTS_STYLE
$URL_STRING_URL_NOHASH_STYLE

url_port
url_alloc
url_realloc
url_cannonicalize
url_abs
url_netloc
url_auth
url_all_path
url_copy
url_free
url_parse
url_dump
url_furl
url_url
url_robots
url2object
url_cannonicalize_string

 );

package urlc;
bootstrap url;
var_url_init();

# ---------- BASE METHODS -------------

package url;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package url;

sub url_port {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = urlc::url_port(@args);
    return $result;
}
sub url_alloc {
    my @args = @_;
    my $result = urlc::url_alloc(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, "url_t", $result;
    return bless \%resulthash, "url_t";
}
sub url_realloc {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = urlc::url_realloc(@args);
    return $result;
}
sub url_cannonicalize {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = urlc::url_cannonicalize(@args);
    return $result;
}
sub url_abs {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = urlc::url_abs(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, "url_t", $result;
    return bless \%resulthash, "url_t";
}
sub url_abs_1 {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = urlc::url_abs_1(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, "url_t", $result;
    return bless \%resulthash, "url_t";
}
sub url_netloc {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = urlc::url_netloc(@args);
    return $result;
}
sub url_auth {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = urlc::url_auth(@args);
    return $result;
}
sub url_all_path {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = urlc::url_all_path(@args);
    return $result;
}
sub url_copy {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = urlc::url_copy(@args);
    return $result;
}
sub url_free {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = urlc::url_free(@args);
    return $result;
}
sub url_parse {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = urlc::url_parse(@args);
    return $result;
}
sub url_dump {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = urlc::url_dump(@args);
    return $result;
}
sub url_furl {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = urlc::url_furl(@args);
    return $result;
}
sub url_url {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = urlc::url_url(@args);
    return $result;
}
sub url_robots {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = urlc::url_robots(@args);
    return $result;
}
sub url2object {
    my @args = @_;
    my $result = urlc::url2object(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, "url_t", $result;
    return bless \%resulthash, "url_t";
}
*url_furl_string = *urlc::url_furl_string;
*url_cannonicalize_string = *urlc::url_cannonicalize_string;

############# Class : url_t ##############

package url_t;
@ISA = qw( url );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "urlc::url_t_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "urlc::url_t_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['info', 'scheme', 'host', 'port', 'path', 'params', 'query', 'frag', 'user', 'passwd', 'pool', 'pool_size', 'furl', 'furl_size', 'url', 'url_size', 'robots', 'robots_size', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['info', 'scheme', 'host', 'port', 'path', 'params', 'query', 'frag', 'user', 'passwd', 'pool', 'pool_size', 'furl', 'furl_size', 'url', 'url_size', 'robots', 'robots_size', ];
        return ();
    }
}


# ------- VARIABLE STUBS --------

package url;

*URL_INFO_CANNONICAL = *urlc::URL_INFO_CANNONICAL;
*URL_INFO_URL = *urlc::URL_INFO_URL;
*URL_INFO_FURL = *urlc::URL_INFO_FURL;
*URL_INFO_RELATIVE = *urlc::URL_INFO_RELATIVE;
*URL_INFO_RELATIVE_PATH = *urlc::URL_INFO_RELATIVE_PATH;
*URL_INFO_EMPTY = *urlc::URL_INFO_EMPTY;
*URL_INFO_HTTP = *urlc::URL_INFO_HTTP;
*URL_INFO_FTP = *urlc::URL_INFO_FTP;
*URL_INFO_NEWS = *urlc::URL_INFO_NEWS;
*URL_INFO_FILE = *urlc::URL_INFO_FILE;
*URL_INFO_ROBOTS = *urlc::URL_INFO_ROBOTS;
*URL_INFO_SCHEME_MASK = *urlc::URL_INFO_SCHEME_MASK;
*URL_NOT_CANNONICAL = *urlc::URL_NOT_CANNONICAL;
*URL_CANNONICAL = *urlc::URL_CANNONICAL;
*URL_FURL_REAL_PATH = *urlc::URL_FURL_REAL_PATH;
*URL_FURL_NOP = *urlc::URL_FURL_NOP;
*URL_STRING_FURL_STYLE = *urlc::URL_STRING_FURL_STYLE;
*URL_STRING_URL_STYLE = *urlc::URL_STRING_URL_STYLE;
*URL_STRING_ROBOTS_STYLE = *urlc::URL_STRING_ROBOTS_STYLE;
*URL_STRING_URL_NOHASH_STYLE = *urlc::URL_STRING_URL_NOHASH_STYLE;
1;
